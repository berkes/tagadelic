<?php
// $Id$

/**
 * Implementation of hook_help
 */
function tagadelic_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Tagadelic makes a page with weighted folksonomy. Folksonomys with lots of articles under them get a big font-size, folksonomy without them, get a small size.');
   case 'admin/help#creativecommons':
      return t('tagadelic offers dynamic urls. <br/>Visit example.com/tagadelic/list/2,1,5 to get the vocabularies 2,1 and 5 listed as tag groups. <br/>Visit example.com/tagadelic/chunk/2,1,5 to get a tag cloud of the terms in the vocabularies 2,1 and 5.<br/> Note that we limit to five vocabularies.');
  }
}

/**
 * Implementation of hook_settings
 */
function tagadelic_settings() {
  return $output;
}

/**
 * Implementation of hook_menu
 */
function tagadelic_menu($may_cache) {
  $items = array();
  drupal_set_html_head('<style type="text/css">@import url('.drupal_get_path('module','tagadelic').'/tagadelic.css);</style>');

  if ($may_cache) {
     $items[] = array('title' => t('tags'),
                      'path' => "tagadelic",
                      'callback' => 'tagadelic_page_chunk',
                      'access' => user_access('access content'),
                      'type' => MENU_SUGGESTED_ITEM);
     $items[] = array('title' => t('tags'),
                      'path' => "tagadelic/list",
                      'callback' => 'tagadelic_page_list',
                      'access' => user_access('access content'),
                      'type' => MENU_CALLBACK);
     $items[] = array('title' => t('tags'),
                      'path' => "tagadelic/chunk",
                      'callback' => 'tagadelic_page_chunk',
                      'access' => user_access('access content'),
                      'type' => MENU_CALLBACK);
     foreach (taxonomy_get_vocabularies($type = NULL) as $vocabulary) {
       if ($vocabulary->tags) {
         $items[] = array('title' => $vocabulary->name,
                          'path' => "tagadelic/chunk/$vocabulary->vid",
                          'callback' => 'tagadelic_page_chunk',
                          'access' => user_access('access content'));
       }
     }
  }
  return $items;
}

/**
 * menu callback renders a tagadelic page
 */
function tagadelic_page_chunk() {
  $vocs = arg(2);

  if (is_numeric($vocs)) {
    $vocs = array($vocs);
  }
  elseif (preg_match('/^([0-9]+,){1,5}[0-9]+$/', $vocs)) {
    $vocs = explode(',', $vocs);
  }
  elseif($vocs == NULL) { //create a chunk from all free tagging vocs
   foreach (taxonomy_get_vocabularies(NULL) as $vocabulary) {
      if ($vocabulary->tags) {
        $vocs[] = $vocabulary->vid;
      }
    }
  }

  $output = theme('tagadelic_weighted',tagadelic_get_weighted_tags($vocs));
  
  if (!$output) {
    return drupal_not_found();
  }

  $output = "<div class=\"wrapper tagadelic\">$output</div>";
  
  return $output;
}

/**
 * menu callback renders a tagadelic page with listed items: each voc
 */
function tagadelic_page_list() {
  $vocs = arg(2);

  if (is_numeric($vocs)) {
    $vocs = array($vocs);
  }
  elseif (preg_match('/^([0-9]+,){1,5}[0-9]+$/', $vocs)) {
    $vocs = explode(',', $vocs);
  }
  else {
    return drupal_not_found();
  }

  foreach ($vocs as $vid) {
    $vocabulary = taxonomy_get_vocabulary($vid);
    if ($vocabulary->description) {
      $output .= theme("box", NULL, $vocabulary->description);
    }
    $output .= theme('box', $vocabulary->name, theme('tagadelic_weighted', tagadelic_get_weighted_tags(array($vocabulary->vid))));
  }
  
  if (!$output) {
    return drupal_not_found();
  }
  
  drupal_set_html_head('<style type="text/css">@import url('.drupal_get_path('module','tagadelic').'/tagadelic.css);</style>');
  
  $output = "<div class=\"wrapper tagadelic\">$output</div>";
  print theme('page', $output);
}

/**
 * API that returns an array with weighted tags
 * This is the hard part. People with better ideas are very very welcome to send these to ber@webschuur.com. Distribution is one thing that needs attention.
 */
function tagadelic_get_weighted_tags($vids, $steps = 6, $size = 60) {
  if (!is_array($vids) || count($vids) == 0) {
    return array();
  }

  // Fetch tags
  $result = db_query_range('SELECT COUNT(*) AS count, d.tid, d.name FROM {term_data} d INNER JOIN {term_node} n ON d.tid = n.tid WHERE d.vid IN ('. substr(str_repeat('%d,', count($vids)), 0, -1) .') GROUP BY d.tid, d.name ORDER BY count DESC', $vids, 0, $size);

  // Find minimum and maximum log-count.
  $tags = array();
  $min = 1e9;
  $max = -1e9;
  while ($tag = db_fetch_object($result)) {
    $tag->count = log($tag->count);
    $min = min($min, $tag->count);
    $max = max($max, $tag->count);
    $tags[$tag->tid] = $tag;
  }  
  // Note: we need to ensure the range is slightly too large to make sure even
  // the largest element is rounded down.
  $range = max(.01, $max - $min) * 1.0001;

  foreach ($tags as $key => $value) {
    $tags[$key]->weight = 1 + floor($steps * ($value->count - $min) / $range);
  }

  // Sort by title
  usort($tags, "_tagadelic_sort_by_title");
  return $tags;
}

/**
 * callback for usort, sort by count
 */
function _tagadelic_sort_by_title($a, $b) {
  return strnatcmp($a->name, $b->name);
}

/**
 * theme function that renders the HTML for the tags
 * @ingroup themable
 */
function theme_tagadelic_weighted($terms) {
  foreach ($terms as $term) {
    $output .= l($term->name,"taxonomy/term/$term->tid", array('class'=>"tagadelic level$term->weight")) ." \n";
  }
  return $output;
}

/**
 * implementation of hook_block
 */
function tagadelic_block($op = 'list', $delta = O) {
  if ($op == 'view') {
    if ($voc = taxonomy_get_vocabulary($delta)) {
      $blocks['subject'] = t('tags in %voc', array('%voc' => $voc->name));
      $blocks['content'] = theme('tagadelic_weighted', tagadelic_get_weighted_tags(array($voc->vid),6, 12));//return a chunk of 12 tags
    }
  }
  elseif ($op == 'list') {
    foreach(taxonomy_get_vocabularies() as $voc) {
      $blocks[$voc->vid]['info'] = t('tags in %voc', array('%voc' => $voc->name));
    }
  }
  return $blocks;
}
?>